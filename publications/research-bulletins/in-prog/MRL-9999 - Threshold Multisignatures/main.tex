\documentclass[12pt,english,oneside]{mrl}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{cite}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[toc,page]{appendix}

\usepackage{todonotes}

\usepackage{enumerate}
\renewcommand{\familydefault}{\rmdefault}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{color}
\usepackage{babel}
\usepackage{verbatim}
\usepackage{float}
\usepackage{url}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[unicode=true,pdfusetitle, bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,  breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]{hyperref}
\usepackage{breakurl}
\usepackage{todonotes}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb,enumerate}
\usepackage{amsthm}
\usepackage{cite}
\usepackage{comment}
\usepackage[all]{xy}
%\usepackage[notref,notcite]{showkeys}
\usepackage{hyperref}
\usepackage{todonotes}

% THEOREM ENVIRONMENTS
\newtheorem*{example}{Example}
\theoremstyle{definition}
\newtheorem{lem}{Lemma}[section]
\newtheorem{cor}[lem]{Corollary}
\newtheorem{prop}[lem]{Proposition}
\newtheorem{thm}[lem]{Theorem}
\newtheorem{soln}[]{Solution}
\newtheorem{conj}[lem]{Conjecture}
\newtheorem{Defn}[lem]{Definition}
\newtheorem{Ex}[lem]{Example}
\newtheorem{Question}[lem]{Question}
\newtheorem{Property}[lem]{Property}
\newtheorem{Properties}[lem]{Properties}
\newtheorem{Discussion}[lem]{Remark}
\newtheorem{Construction}[lem]{Construction}
\newtheorem{Notation}[lem]{Notation}
\newtheorem{Fact}[lem]{Fact}
\newtheorem{Notationdefinition}[lem]{Definition/Notation}
\newtheorem{Remarkdefinition}[lem]{Remark/Definition}
\newtheorem{rem}[lem]{Remark}
\newtheorem{Subprops}{}[lem]
\newtheorem{Para}[lem]{}
\newtheorem{Exer}[lem]{Exercise}
\newtheorem{Exerc}{Exercise}

\newenvironment{defn}{\begin{Defn}\rm}{\end{Defn}}
\newenvironment{ex}{\begin{Ex}\rm}{\end{Ex}}
\newenvironment{question}{\begin{Question}\rm}{\end{Question}}
\newenvironment{property}{\begin{Property}\rm}{\end{Property}}
\newenvironment{properties}{\begin{Properties}\rm}{\end{Properties}}
\newenvironment{notation}{\begin{Notation}\rm}{\end{Notation}}
\newenvironment{fact}{\begin{Fact}\rm}{\end{Fact}}
\newenvironment{notationdefinition}{\begin{Notationdefinition}\rm}{\end{Notationdefinition}}
\newenvironment{remarkdefinition}{\begin{Remarkdefinition}\rm}{\end{Remarkdefinition}}
\newenvironment{subprops}{\begin{Subprops}\rm}{\end{Subprops}}
\newenvironment{para}{\begin{Para}\rm}{\end{Para}}
\newenvironment{disc}{\begin{Discussion}\rm}{\end{Discussion}}
\newenvironment{construction}{\begin{Construction}\rm}{\end{Construction}}
\newenvironment{exer}{\begin{Exer}\rm}{\end{Exer}}
\newenvironment{exerc}{\begin{Exerc}\rm}{\end{Exerc}}

\newtheorem{intthm}{Theorem}
\renewcommand{\theintthm}{\Alph{intthm}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}
\providecommand{\algorithmname}{Algorithm}
\floatname{algorithm}{\protect\algorithmname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{algpseudocode}

\usepackage{subcaption}

\numberwithin{equation}{section}


\makeatletter


\makeatletter

\newcommand{\h}{\mathcal{H}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}
\providecommand{\algorithmname}{Algorithm}
\floatname{algorithm}{\protect\algorithmname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{algpseudocode}


\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother


\begin{document}
\begin{frontmatter}

\begin{fmbox}
\hfill\setlength{\fboxrule}{0px}\setlength{\fboxsep}{5px}\fbox{\includegraphics[width=2in]{moneroLogo.png}}
\dochead{Research Bulletin \hfill MRL-9999}
\title{Threshold Ring Confidential Transactions}
\date{\today}
\author[
   addressref={mrl},
   email={bggoode@g.clemson.edu}
]{\fnm{Brandon} \snm{Goodell}}
\author[
   addressref={mrl},
   email={sarang.noether@protonmail.com}
]{\fnm{Sarang} \snm{Noether}}


\address[id=mrl]{
  \orgname{Monero Research Lab}
}
\end{fmbox}

\begin{abstractbox}
\begin{abstract}
This research bulletin extends \cite{noether2016ring} by constructing a $t$-of-$n$ threshold multi-layered linkable spontaneous anonymous group signature scheme ($t$-of-$n$ MLSAG) in the same style as the LSAG schemes put forth by \cite{liu2004linkable}. %We present security models for this scheme, present security proofs in those models, describe an implementation, and explain some use-cases for the scheme in cryptocurrencies.
\end{abstract}
\end{abstractbox}
\end{frontmatter}


\section{Introduction and Background}

Ring signatures can play a critical role in establishing user anonymity (or at least user ambiguity) during message authentication. Due to this utility, ring signatures enjoy application in many cryptocurrency protocols. Multisignatures play a critical role in off-chain transactions for cryptocurrencies (e.g.\ the Bitcoin Lightning Network) and for message authentication in general (e.g.\ multi-factor authentication). It is natural to extend the notion of ring signatures to ring multisignatures for implementation in cryptocurrencies to enjoy signer-ambiguous multisignatures. We investigate $t$-of-$N$ threshold multisignatures. A multisignature scheme is a $t$-of-$N$ \textit{ring threshold multisignature} (RTM) scheme if any set of $N$ keys may be specified as a coalition of signers and assigned a shared public key such that any $t$ coalition members may collaborate to fashion a signature on behalf of the shared public key. A usual digital signature scheme is a $1$-of-$1$ multisignature scheme, so we can regard all keys as shared public keys (just perhaps with a coalition of only one member).

If the number of users cooperating in the construction of a signature is not secret, naive multisignature schemes can be constructed from any signature scheme (ring signature or otherwise) by simply requiring each participating user to present a separate signature. More sophisticated implementations combine these together using boolean AND circuits as in the Borromean ring set-up described in \cite{} for efficiency reasons. 

If a user does not desire to reveal to an adversary how many devices were used for some multi-factor authentication, it should be difficult for an adversary to determine the size of a coalition behind some shared public key. This property should be satisfied even if the adversary can persuade the party (or parties) controlling the shared public key to sign arbitrary messages chosen by the adversary. We introduce the security definition of \textit{coalition-indistinguishable} multisignature schemes against adaptive chosen message attacks: given a shared $t$-of-$N$ public key $X$, an adversary prompts the coalition in control of $X$ to produce signatures on a set of messages and should be unable to guess any information about $t$ or $N$.

Note that this property cannot be satisfied if the adversary has corrupted any public key in the coalition. If some coalition member for $X$, say $X^{\prime}$, is a shared $t^{\prime}$-of-$N^{\prime}$ public key, this means that if the adversary has corrupted $t^{\prime}$ or more members of the coalition for $X^{\prime}$, then coalition-indistinguishability is impossible. Thus we investigate the notion of \textit{subthreshold corruption oracle access}.

Note that a $1$-of-$N$ threshold signature scheme may be accomplished by simply handing out an identical set of keys to $N$ individuals: whoever decides to use them first will be able to fashion a signature. We consider this a degenerate case. On the other hand, a $1$-of-$1$ signature scheme is a usual signature scheme, as we mentioned. %Moreover, for multifactor authentication purposes, $(N-1)$-of-$N$ and $N$-of-$N$ schemes are of particular interest. Due to this, we consider only $t$-of-$N$ threshold ring signatures with $N-1 \leq t \leq N$, with $t > 1$, and with $N > 1$.



\subsection{Our Contribution}

%We describe an implementation of $t$-of-$N$ LSAG signatures first described by previous MRL contributors Shen Noether in \cite{noether2016ring} and implemented for use in Monero  by contributor \texttt{Luigi}. %We consider definitions of security for these schemes, and we propose an implementation.



\subsection{Notation and Prerequisites}

%We denote the message space $\mathcal{M}=\left\{0,1\right\}^*$. We let $\mathbb{G}$ be an additive group with prime order $q$ an an arbitrary generator $G$. We denote $H_{\mathcal{X},\mathcal{Y}}(-)$ as a cryptographic hash function from the space $\mathcal{X}$ to $\mathcal{Y}$. For example $H_{\mathbb{G},\mathbb{Z}_q}(-)$ is a cryptographic point-to-scalar function. We assume that any two hash functions $H_{\mathcal{X},\mathcal{Y}}(-)$ and $H_{\mathcal{X}^{\prime},\mathcal{Y}^{\prime}}(-)$ are statistically independent.


\section{MLSAG Ring Signatures}


We briefly describe LSAG ring signatures in the sense of \cite{liu2004linkable} and their MLSAG variant used in Monero. Let $Q$ denote the set of ring members (public keys) $Q=\left\{Y_1, \ldots Y_L\right\}$. Let $k$ be a distinguished index in this set corresponding to the signing key $Y_{k}$. Let $y_{k} \in \mathbb{Z}_q$ such that $Y_{k} = y_{k} G$. Let $m$ be a message. A signer computes a key image $J$ based on the private key $y_{k}$. %Key images can be selected somewhat freely by demanding simply that they are elliptic curve points that depend on a commitment to the secret key $x_{i^{\prime}}$ and we require a negligible advantage in linking a key image and a public key. 

For each $i$, the signer computes an elliptic curve point from the $i^{th}$ ring member public key  as $H_i := H_{p}(Y_i)$. The signer selects a random secret $u \in_R \mathbb{Z}_q$, computes an initial temporary pair of points $uG$ and $uH_{k}$, and computes an initial commitment $c_{k+1} := H_{p}(m,uG, uH_k)$. The signer sequentially proceeds through indices $i=k+1, k+2, \ldots, n, 1, 2, \ldots, k-1$ in the following way. The signer selects at random secret $s_i \in_R \mathbb{Z}_q$, computes the next temporary pair of points $s_iG + c_i Y_i$ and $s_i H_i + c_i J$, and computes the next commitment $c_{i+1}:=H_{p}(m,s_i G + c_i Y_i, s_i H_i + c_i J)$. The signer continues proceeding through the set of keys until commitments $c_i$ have been computed for each $i=1, ... L$. The signer then computes $s_{k}:=u - c_{k}y_{k}$ and publishes the signature $(c_1, s_1, \ldots, s_n, J)$.

A signature $(c_1^*, s_1^*, \ldots, s_n^*, J^*)$ on $m$ can be verified to have been generated by at least one member of the ring's private key in the following way: for each $i=1,2,\ldots, L$, the verifier computes $z_{i} = s_i^* G + c_i^* Y_i$ and $z_{i}^{\prime} = s_i^* H_i + c_i^* I^*$ and uses these to compute the $(i+1)^{th}$ commitment $c_{i+1} = H_{\mathcal{M}, \mathcal{G}}(m, z_i, z^{\prime}_i)$. After computing $c_2, c_3, \ldots, c_L, c_1$, the verifier approves of the signature if and only if $c_1 = c_1^*$.

The MLSAG generalization, where user keys are represented by vectors, is straightforward. For a user with secret key $\underline{y}=(y_1,\ldots,y_w)$, each component of this key vector is used to generate a temporary pair of points (like $uG$, $uH_k$ in the first step of constructing a ring signature, or $s_i G + c_i Y_i$, $s_i H_i + c_i J$). This provides the associated commitment
\[c_{i+1}:=H_{\mathcal{M}, \mathcal{G}}\left(m,\left\{(s_{i,j} G + c_i Y_{i,j}, s_{i,j} h_{i,j} + c_i I)\right\}_{j=1}^{w}\right).\]



\subsection{Extending to Threshold Signatures} \label{naiveImplement}

Generally, we wish to allow a coalition of users with the public keys $X=\left\{X_{1}, X_{2}, \ldots, X_{N}\right\}$ (where each $X_i = x_iG$) to collaboratively fashion a shared public key $Y$ (which we call a $t$-of-$N$ \textit{shared public key}) such that any subset of at least $t$ of the users in $X$ can collaborate to fashion a signature on a message with corresponding public key $Y$. In the $N$-of-$N$ case, one such implementation works in the following manner. 

Given message $m$, a coalition of friends with the public keys $X=\left\{X_{1}, X_{2}, \ldots, X_{N}\right\}$  compute a shared public key $Y_{\texttt{shared}} := \sum_{j=1}^{n} X_j$, which is published. They select their ring to be a set of public keys $Q = \left\{Y_1, Y_2, \ldots, Y_L\right\}$ such that $Y = Y_{k}$ for some secret index $s$. Each user can compute $H_i = H_{p}(Y_i)$ for each $Y_i \in Q$. For each $1 \leq j \leq N$, the $j^{th}$ signer (who owns the secret key $x_{j}$) computes a partial key image $I_j = x_j H_{k}$, picks a random initial temporary secret $u_j$, and shares the triple of points $I_j, u_j G, u_j H_{k}$ with the other signers. Now any of these users may compute the key image $J = \sum_j I_j$, the random points $u_{k} G = \sum_j u_{j} G$ and $u_{k} H_{k}= \sum_j u_{j} H_{k}$. 

Using these, any of these users may compute the first in the sequence of commitments $c_{k+1} := H_{p}(m,  u_k G, u_k H_k)$. The group decides upon random values $s_{k+1}, \ldots, s_{L}, s_1, \ldots, s_{k-1}$ and computes each $c_{i+1} := H_{p}(m,  s_{i} G + c_i Y_i, s_{i} H_i + c_i J)$ for $i=k+1, \ldots, k-1$. All threshold members then use $c_k$ to compute their $s_{k,j} = u_j - c_{k} x_j$. The signers share their $s_{k,j}$ with the other signers. Any threshold member may then compute the value $s_{k} = \sum_j s_{k,j}$ and publish the signature $(c_1, s_1, \ldots, s_L, J)$. Any user may verify this signature corresponds to the $N$-of-$N$ shared public key $Y$.

The above set-up extends naturally to an $(N-1)$-of-$N$ set-up. As before, a set of $N$ public keys $\left\{X_{1}, X_{2}, \ldots, X_{N}\right\}$ form a coalition. Each pair of users has a shared secret scalar $z_{i,j} = H_{s}(x_i X_j)$ with associated public point $Z_{ij} = z_{i,j}G$. There are $\frac{N(N-1)}{2}$ such pairs; if any $N-1$ members get together, all of the associated shared secrets are known. Hence, we may simply instantiate the $(N-1)$-of-$N$ threshold as an $N^*$-of-$N^*$ set-up with $N^* = \frac{N(N-1)}{2}$, wherein all values $z_{i,j}$ are necessary to fashion a signature with the public key $Y_{\texttt{shared}}:=\sum_{1 \leq i \leq n} \sum_{i < j \leq n} Z_{i,j}$.

This implementation may not satisfy very strong security definitions. For example, in the above description, an adversary with knowledge of the underlying public keys $X_i$ can trivially test whether a certain public key $Y$ in some ring $Q$ is a multisignature key by simply computing $\sum_i X_i$. We discuss this and other properties in greater detail.




\section{Security Models}

In this section we present definitions we use later on. We immediately make use of the following observation: in a threshold multisignature scheme, coalitions of users collaborate to generate new threshold keys from sets of old keys and to generate signatures on messages using those threshold keys. This collaboration uses secret information each coalition member wishes to keep private from the rest of the coalition (and certainly any adversary outside of the coalition). In order to make rigorous any notion of security in an environment where threshold keys can be used to create threshold keys, we introduce the idea of the \textit{depth} of a threshold public key.

We say a usual public key $Y$ (as in a usual ring signature scheme) has \textit{depth} $\texttt{depth}(Y):=0$. For a threshold public key $Y$, we denote the set of public keys used to compute threshold ring signatures on behalf of $Y$ as $\texttt{pub}(Y)$. We say that a $t$-of-$N$ threshold public key $Y$ has $\texttt{depth}(Y):=1$ if each of the $N$ elements in $\texttt{pub}(Y)$ have depth $0$. For any set of public keys $S$, we define $\texttt{pub}\left(S\right) = \cup_{Y \in S} \texttt{pub}(Y)$. In the case that some public key in $\texttt{pub}(Y)$ is, itself, a threshold public key, we abuse operator notation to denote  $\texttt{pub}\circ\texttt{pub}(Y) = \texttt{pub}^2(Y)$, and so on. For consistency, we define $\texttt{pub}^0(Y) = \left\{Y\right\}$.  Hence, we iteratively define depth in the following way. We say that a threshold public key $Y$ has $\texttt{depth}(Y):=\text{max}_{Y^{\prime} \in \texttt{pub}(Y)}\left\{\texttt{depth}(Y^{\prime}) +1\right\}$. Define the set $\tilde{Y}:= \cup_{i=0}^{d_Y}\texttt{pub}^{i}(Y)$. Note that each threshold public key $Y^{\prime} \in \texttt{pub}(Y)$ has depth at most $d_Y - 1$ and if $Y$ is $t_Y$-of-$N_Y$, then $\left|\texttt{pub}(Y)\right| = N_Y$. 


In our threshold signature scheme, the private keys for any given threshold public key are never revealed. The only private keys known by any user are the private keys associated with their usual public key. We denote $\texttt{priv}(\tilde{Y})$ as the set of all private keys used to compute any threshold ring signature on behalf of $Y$.


\begin{defn}{[Ring Threshold Multisignature Scheme]}\label{RTM} A ring threshold multisignature (RTM) scheme is a quadruple of PPT algorithms, $(
\texttt{GEN},\texttt{MERGE},\texttt{SIG},\texttt{VER})$ that, respectively, generate private-public keypairs for users, merge sets of public keys and threshold numbers into new public keys, fashion signatures on messages given a ring of public keys, and verifies signatures. We later restrict Definition \ref{RTM} so as to only generate $N$-of-$N$ and $(N-1)$-of-$N$ signatures. Formally:
\begin{enumerate}[(i)]
    \item $\texttt{GEN}(-)$ takes as input a security parameter $1^\lambda$ and outputs a $1$-of-$1$ threshold keypair $(x,X)$ where $x$ is a private key with associated public key $X$.
    \item $\texttt{MERGE}(-,-)$ takes as input keypairs $S=\left\{(x_1,X_1), (x_2,X_2), \ldots, (x_n,X_N)\right\}$ and a positive integer (threshold) $t$ and outputs a $t$-of-$N$ public key $X$ for fashioning $t$-of-$N$ threshold multisignatures.
    \item $\texttt{SIG}(-,-,-,-)$ takes as input message $M$, ring of public keys $R=\left\{X_1, \ldots, X_L\right\}$, secret index $s$, and set $\texttt{priv}(\tilde{X}_s)$ and outputs signature $\sigma$.
    \item $\texttt{VER}(-,-,-)$ takes as input a message $M$, a ring of public keys $R$, and a signature $\sigma$, and outputs a bit $b \in \left\{0,1\right\}$. 
\end{enumerate}
We require the scheme to be \textit{complete} in the sense that, for any message $M$, any ring of public keys $R = \left\{X_i\right\}_{i=1}^{L}$, and for any index $1 \leq s \leq L$, $\texttt{VER}(M,R,\texttt{SIG}(M,R,s,\texttt{priv}(\tilde{X}_s)))=1$.
\end{defn}

%Note that $\texttt{MERGE}$ and $\texttt{SIG}$ both take secret information as input; in general, this algorithm must be executed collaboratively.



Definition \ref{threshIndist} formalizes the idea that an adversary should not be able to link a public key with the threshold size, $t$, the coalition size, $N$, or the depth of the coalition except with negligible probability. %Definition \ref{threshIndist} emphasizes the idea that the \textit{method of collaboratively fashioning keys} is not easily discernible by an adversary.

\begin{defn}[Coalition Indistinguishable Keys]\label{threshIndist} Let $\mathcal{A}$ be a PPT adversary and let $D(-)$, $M(-)$ be positive polynomials.
\begin{enumerate}[(i)]
\item $\mathcal{A}$ selects a random triple of integers $(t_0,N_0, d_0)$ such that $2 \leq t_0 \leq N_0 \leq M(\lambda)$ and $0 \leq d_0 \leq D(\lambda)$.
\item A random triple of integers $(t_1, N_1, d_1)$ are selected such that $2 \leq t_1 \leq N_1 \leq M(\lambda)$ and $0 \leq d_1 \leq D(\lambda)$. A random bit $b$ is selected. A coalition $S$ is generated such that $0 \leq\texttt{depth}(S) \leq d_b$ and $\left|S\right|=N_b$. 
\item The key $X_{b} \leftarrow \texttt{MERGE}(t_{b}, S)$ is sent to $\mathcal{A}$.
\item $\mathcal{A}$ outputs a bit $b^{\prime}$. This counts as a success if $b=b^{\prime}$.
\end{enumerate}
We say an RTM scheme has Coalition Indistinguishable Keys (CIK) if the adversary can succeed with probability only negligibly more than $1/2$.
\end{defn}

Definition \ref{threshIndist} does not take into account the fact that the adversary may learn the public keys of the coalition $S$ generated in step (ii) above. Due to this, the naive implementation in Section \ref{naiveImplement} does not satisfy coalition indistinguishability for keys: an adversary who learns the public keys of a coalition can certainly check whether a certain elliptic curve point is their sum!  We may also modify that implementation so that $Y_{\texttt{shared}} = \sum_{i=1}^{N} \sum_{j=1}^{N} H_s(Z_{i,j}, \mu_{i,j})G$, which clearly re-uses keys; this presents no algebraic danger, and allows for recursive implementation.

The implementation in Section \ref{naiveImplement} may be tweaked to satisfy CIK by having coalition members compute the shared key as $Y_{\texttt{shared}} := \sum_j H_s(X_j)G$ (in the $N$-of-$N$ case) or as $Y_{\texttt{shared}} := \sum_{1 \leq i < j \leq N} H_s(Z_{i,j}, \mu_{i,j})G$ (in the $(N-1)$-of-$N$ case). Still, each $H_s(X_j)G$ or $H_s(Z_{i,j})G$ must be communicated to the coalition, and if the adversary discovers these scalars, the adversary may simply check whether a given public key $Y$ is the sum. Hence, these points must be communicated with encryption. If we allow users to compute their shared key as $Y_{\texttt{shared}} = \sum_j H_s(X_j, \mu_j) G$ for some constants $\mu_j$, then we may also reduce the advantage enjoyed by an adversary in the game of Definition \ref{threshIndist}, even if that adversary is granted (limited) corruption oracle access. 


%In \cite{bender2006ring}, anonymity in ring signatures assumes at least two honest users in each ring, because if the adversary controls all keys except a single key controlled by an honest user, that adversary can certainly identify whether that honest user fashioned a signature!  %The adversary does not even need to know private information to violate coalition indistinguishability. %In fact, by merely knowing the CryptoNote public view key of a set $S$ of $N$ possible signers, an adversary may trivially check if some CryptoNote key pair $(A,B)$ is an $N$-of-$N$ key pair for the coalition $S$. 

%If granted corruption oracle access, any threshold subset of a coalition will also degrade coalition indistinguishability. To see why, assume the adversary is granted access to a corruption oracle and has corrupted a threshold subset of $S$. The adversary will then be able to construct valid signatures without the signing oracle, and will be able to conclude some information about the threshold, allowing for non-negligible success probability in the game of Definition \ref{threshIndist}. 

%Although we cannot strengthen Definition \ref{threshIndist} to take into account corruption by the adversary, 
We may strengthen Definition \ref{threshIndist} to allow $\mathcal{A}$ to obtain signatures on arbitrary messages:

\begin{defn}[Coalition Indistinguishable Keys and Signatures]\label{threshIndistSigs} Let $\mathcal{A}$ be a PPT adversary and let $D(-)$, $M(-)$ be a non-negative polynomial. Let $\mathcal{SO}(-,-)$ be a signing oracle.
\begin{enumerate}[(i)]
\item $\mathcal{A}$ selects a random triple of integers $(t_0,N_0, d_0)$ such that $2 \leq t_0 \leq N_0 \leq M(\lambda)$ and $0 \leq d_0 \leq D(\lambda)$.
\item A random triple of integers $(t_1, N_1, d_1)$ are selected such that $2 \leq t_1 \leq N_1 \leq M(\lambda)$ and $0 \leq d_1 \leq D(\lambda)$. A random bit $b$ is selected. A coalition $S$ is generated such that $0 \leq\texttt{depth}(S) \leq d_b$ and $\left|S\right|=N_b$. 
\item The key $X_{b} \leftarrow \texttt{MERGE}(t_{b}, S)$ is sent to $\mathcal{A}$. $\mathcal{A}$ is granted oracle access to $\mathcal{SO}$.
\item $\mathcal{A}$ outputs a bit $b^{\prime}$. This counts as a success if $b=b^{\prime}$.
\end{enumerate}
We say an RTM scheme has Coalition Indistinguishable Keys and Signatures (CIKS) if the adversary can succeed with probability only negligibly more than $1/2$.
\end{defn}

Note that by giving $\mathcal{A}$ the public key $X_b$ and signing oracle access, if $\mathcal{A}$ can discern non-negligible information about threshold $t$ or coalition size $N$ or depth $d$ by inspecting a signature $\sigma$, then $\mathcal{A}$ succees non-negligibly at the game in Definition \ref{threshIndistSigs}. Hence, a CIKS RTM scheme is an RTM scheme through which attackers are unable to link threshold size, coalition size, or depth to any given public key or signature.

In addition to coalition indistinguishability, we wish our signature scheme to have the usual property of digital signatures of \textit{existential unforgeability} in the face of adaptive chosen message attacks, as well as the ring signature property of \textit{signer ambiguity}. Variations of these security models describing insider corruption and adversarially generated keys appear in \cite{bender2006ring}. One may consider further expanding these definitions of existential unforgeability and signer ambiguity to take into account subthreshold corruption. 

\begin{defn}{[Subthreshold Oracle Access]}
Given any set of public keys $Q = \left\{Y_1, \ldots, Y_L\right\}$, we say that any PPT adversary $\mathcal{A}$ with access to an oracle $\mathcal{O}(-)$ has had \textit{subthreshold oracle access} to $Q$ if, for any $Y \in Q$ and $Y^{\prime} \in \tilde{Y}$, at most $t_{Y^{\prime}}-1$ members of $\texttt{pub}(Y^{\prime})$ appear in the transcript between $\mathcal{A}$ and $\mathcal{O}(-)$.
\end{defn}

However, allowing for subthreshold corruption oracle access immediately degrades the definitions of signer amgibuity and CIK(S). Consider, for example, the definition of signer ambiguity against adversarially generated keys from \cite{bender2006ring}.

\begin{defn}{[Signer Ambiguity v. Adversarially Generated Keys]} Let $L(-)$ be a positive polynomial. Let $\mathcal{A}$ be a PPT adversary. Let $\mathcal{A}$ have access to a signing oracle $\mathcal{SO}(-,-,-)$ that outputs the valid signature $\texttt{SIG}(-,-,-,-)$. Consider the following game:
\begin{enumerate}[(i)]
\item A set of keypairs is generated $\left\{(x_i, X_i)\right\}_{i=1}^{L(\lambda)} \leftarrow \texttt{GEN}(1^\lambda)$ and the set of public keys $S = \left\{X_i\right\}_{i=1}^{L(\lambda)}$ is sent to $\mathcal{A}$.
\item $\mathcal{A}$ outputs a message $M$, a ring of public keys $R = \left\{Y_1, \ldots, Y_{L^*}\right\}$, and two distinct indices $i_0 \neq i_1$ such that $Y_{i_0}, Y_{i_1} \in S$.
\item A random bit $b$ is chosen and $\sigma \leftarrow \texttt{SIG}(M,R,i_b,y_{i_b})$ is sent to $\mathcal{A}$.
\item $\mathcal{A}$ outputs a bit $b^{\prime}$. The game counts as a success if $b = b^{\prime}$ and neither $(i_0,M,R)$ nor $(i_1,M,R)$ appear in the transcript between $\mathcal{A}$ and $\mathcal{SO}$.
\end{enumerate}
We say the RTM scheme is \textit{signer ambiguous with respect to adversarially generated keys} if the probability that $\mathcal{A}$ succeeds is negligibly close to $1/2$ (with respect to $\lambda$).
\end{defn}

We may be tempted to expand this definition to take into account an adversary who has subthreshold corruption oracle access to $\tilde{Y}_{i_0}$ and $\tilde{Y}_{i_1}$. However, this definition is (in some sense), as good as we can get for signer ambiguity in a RTM scheme made linkable by key images as described in Section \ref{naiveImplement}. Indeed, every coalition member computes the key image based solely on their private keys and can therefore check if a signature has been computed on behalf of the shared public key of the coalition.  Hence, if an adversary is granted corruption oracle access (or even subthreshold corruption oracle access) to a signing coalition, signer ambiguity is violated. Similarly, an adversary with subthreshold corruption oracle access also violates CIK(S), because the adversary can gain non-trivial amounts of information about both threshold and coalition size during the corruption process. 

We do not consider these to be serious violations of the security definitions, because the adversary is applying their corruption oracle access to information used to compute the associated signing public key, partially corrupting the signers. We speculate that modifications to our construction of key images may allow for stronger notions of signer ambiguity in the future without sacrificing robustness against double-spend attacks (e.g.\ by taking key images as homomorphic commitments, two commitments may be linked if their difference is a commitment to zero without revealing their masks), but that is beyond the scope of this document.




%Every signature scheme is only as useful as its unforgeability properties in the face of an adversary with corruption and signing oracle access. Previous security definitions as in \cite{bender2006ring} do not take into account threshold multisignatures. Indeed, an attacker with at most subthreshold corruption oracle access to $R$ should also be unable to forge a signature:

On the other hand, unforgeability of a RTM scheme must take into account subthreshold corruption oracle access. Multisignatures must not be forgeable by a subthreshold collection of malicious coalition members, otherwise they have no utility as signatures.

\begin{defn}{[Existential Unforgeability v. Adaptive Chosen Message and Subthreshold Insider Corruption]} Let $\mathcal{A}$ be a PPT adversary and $L(-)$ and $D(-)$ be non-negative polynomials. $\mathcal{A}$ is given access to a signing oracle $\mathcal{SO}$ and a corruption oracle $\mathcal{CO}$. Consider the following game:

\begin{enumerate}[(i)]
\item Key pairs $\left\{(x_i, X_i)\right\}_{i=1}^{L(\lambda)}$ are generated using $\texttt{GEN}(1^\lambda)$ and $\texttt{MERGE}$ such that the set $S = \left\{X_i\right\}_{i=1}^{L(\lambda)}$ satisfies $\texttt{depth}(S) \leq D(\lambda)$. The set $S$ is given to $\mathcal{A}$.
\item $\mathcal{A}$ outputs a ring $R$, a message $M$, and a signature $\sigma$. The game counts as a success if $R \subseteq S$, no public key $Y \in R$ appears in the transcript between $\mathcal{A}$ and $\mathcal{CO}$, $\mathcal{A}$ has had subthreshold corruption oracle access to $R$, $\texttt{VER}(M,R,\sigma)=1$, and for each index $k$, $(k,M,R)$ does not appear in the queries between $\mathcal{A}$ and $\mathcal{SO}$.
\end{enumerate}
A scheme in which an adversary is only negligibly likely to succeed is said to be \textit{existentially unforgeable with respect to adaptive chosen message attacks and subthreshold insider corruption} or merely \textit{st-EUF} for subthreshold existentially unforgeable.
\end{defn}





\section{Proposed Implementation}\label{sec:implement}

We provide an implementation of the above scheme in the spirit of the original CryptoNote methodology, restricted to $N$-of-$N$ and $(N-1)$-of-$N$ coalitions of $\texttt{depth}$ zero keys. For reference CryptoNote addresses, user secret keys and public keys are both ordered pairs of keys, i.e.\ private key $(a,b)$ and public key $(A,B)$ (where, for some group generator $G$ in a group $\mathbb{G}$ where DDH holds, $A=aG$ and $B=bG$). Following terminology from \cite{van2013cryptonote}, we refer to $(a,A)$ as the \textit{view keypair} and $(b,B)$ and the \textit{spend keypair}.  We let $\Pi = (\texttt{GEN}^*,\texttt{ENC}^*, \texttt{AUTH}^*, \texttt{VER}^*, \texttt{DEC}^*)$ be a secure encrypt-then-authenticate scheme (where $\Pi^* = (\texttt{GEN}^*,\texttt{ENC}^*, \texttt{DEC}^*)$ is a secure encryption sub-scheme and $\Pi^{\prime} = (\texttt{GEN}^*,\texttt{AUTH}^*, \texttt{VER}^*)$ is a secure message authentication sub-scheme). We use both of these schemes for computing sums, so the encryption and decryption algorithms may be taken as an homomorphic encryption scheme.

\texttt{GEN} generates the secret key $z=(a,b)$ by selecting $a,b$ from an i.i.d.\ uniform distribution on $\mathbb{Z}_q$, and computing $Z=(A,B)$ with $A:=aG$ and $B:=bG$. \texttt{GEN} then outputs $(z,Z)$.

\texttt{MERGE} takes as input a threshold $t$ and a set of key pairs $S=\left\{(z_1,Z_1), \ldots, (z_n,Z_N)\right\}$ (where each $Z_i = (A_i,B_i)$) such that $N-1 \leq t \leq N$ and $2 \leq t$. 
\begin{enumerate}[(1)]
\item Each member of the coalition selects constants $\mu_i, \gamma_i$ for the multisig address\footnote{One way to do this is for a user to attach an plaintext label to a multisig address like $L=\text{``Escrow wallet for Joe's Coffee''}$ and to compute constants with hash functions and salts, $H_s(L, v)$}. 
\item Each member derives a partial secret keypair $(a^*_i, b^*_i)$ where $a^*_i = H_s(a_i, \mu_i)$ and $b^*_i = H_s(b_i, \gamma_i)$. 
\item Each member uses $\Pi^{\prime}$ to send $(A^*_i, B^*_i)$ to the coalition.
\item If $t=N$, then the coalition uses $\Pi$ to collaboratively compute the shared secret view key $a^* = \sum_i a^*_i$\footnote{Note that although secret information is about $a_i$ not being directly shared with the coalition, the result of the computation is, in fact, a secret key, $a^*$.}, uses $\Pi^{\prime}$ to collaboratively compute the shared public spend key $B^* = \sum_{i=1}^{N} B^*_i$, and then uses $\Pi$ to collaboratively compute the key image $J = \sum_{i=1}^{N} b^*_i H_p(B^*)$.
\item If $t=N-1$, then:
\begin{enumerate}[(a)]
\item For each $i,j$, a partial shared secret view key $\alpha_{i,j} := H_s(a^*_iA^*_i)$ and a partial shared secret spend key $\beta_{i,j} := H_s(b^*_iB^*_i)$ is computed by either participant $i$ or $j$.
\item Set $N^* := \frac{N(N+1)}{2}$, $S^* := \left\{((\alpha_{i,j},\beta_{i,j}), (\alpha_{i,j}G, \beta_{i,j}G))\right\}_{1 \leq i < j \leq N}$, and run $\texttt{MERGE}(N^*, S^*)$.
\item Any coalition member may compute the key image $J$ and publish the CryptoNote public key $(A^*, B^*)$.
\end{enumerate}
\end{enumerate}


\texttt{SIG} takes as input a message $M$, a set of public keys $\left\{(A_1, B_1), \ldots, (A_L, B_L)\right\}$, a secret index $1 \leq k \leq L$ such that $(A_k, B_k)$ is a $t$-of-$N$ threshold public key pair with $2 \leq N-1 \leq t \leq N$, and a set of $t$ private keys $\left\{(a^*_i, b^*_i)\right\}_{i=1}^{t}=\texttt{priv}\left(\widetilde{(A_k,B_k)}\right)$.
\begin{enumerate}[(1)]
\item A set $\left\{s_{k+1}, s_{k+2}, \ldots, s_{k-1}\right\}$ of i.i.d.\ observations of uniform random variables are generated and shared among the coalition using $\Pi^{\prime}$.\footnote{We recommend that a coordinating user randomly selects these using a cryptographic random number generator; only the user coordinating the signature needs these values.}
\item The $j^{th}$ signatory selects a random $u_{j} \leftarrow{\mathbb{Z}_q}$, computes $H_i:=H_{p}(B_i)$ for each index $1 \leq i \leq L$, and computes the points $u_jG$ and $u_jH_{k}$. The coalition uses $\Pi^{\prime}$ to collaboratively compute $u_{k}G := \sum_j u_j G$ and $u_k H_k:= \sum_j u_j H_{k}$.

\item Some threshold member computes $c_{k+1} = H_{p}(m, u_{k} G, u_{k} H_{k})$ and iteratively computes $c_{i+1} = H_{p}(m, s_i G + c_i B_i, s_i H_{i} + c_i J)$ for $i=k+1, k+2, \ldots, k-1$.
\item The threshold member from the previous step uses $\Pi^{\prime}$ to send $c_{k}$ to all other signers with authentication.
\item If $t=N$, each signatory computes their personal $s_{k,j} := u_j - c_{k} b_j^*$. If $t=N-1$, each signatory computes $s_{k,j} = u_j - c_{k} \sum_{i=1}^{L}z_{i,j}$. The coalition uses $\Pi^{\prime}$ to collaboratively compute $s_k = \sum_j s_{k,j}$
\item Any signatory may now publish $(c_1, s_1, \ldots, s_N, J)$.
 \end{enumerate}
 
\begin{disc} The resulting signature takes the same form as LSAG signatures as in \cite{liu2004linkable}. Modifying the above to appropriately to take into account key vectors provides the generalization to MLSAG signatures. Thus the verification algorithm for these signatures is identical to the verification algorithm for usual MLSAG signatures and we omit its description.
\end{disc}
 
 \begin{disc}
 Each $u_j$ is kept secret from the other users and is generated randomly when the signature process begins. Certainly if $u_j$ is revealed to another signatory, since the values of $s_j$ and $c_i$ are communicated in with authentication but not encryption, revealing the value $u_j - c_{i^{\prime}} x_j$ can lead an observer to deduce $x_j$. Encryption does not solve the problem if threshold members are untrustworthy.
 
 
 Similarly, if some value of $u_j$ is re-used twice with the same private key, an observer can deduce the private key. Indeed, assuming we are using a hash function resistant to second pre-image attacks, the commitments from two signature processes $c_{i^{\prime}}, c_{i^{\prime}}^*$ are unequal except with negligible probability even if the other threshold members are colluding. Hence since $s_{i^{\prime},j} = u_j - c_{i^{\prime}} x_{j}$ and $s_{i^{\prime},j}^* = u_j - c_{i^{\prime}}^* x_{j}$, an observer may solve for the private key $x_j$. Don't re-use values of $u_j$, keep them secret, generate them randomly.
 
 \end{disc}
 
 \begin{disc}  Note that users in $(N-1)$-of-$N$ processes are prompted to select constants $\mu, \gamma$ multiple times for multiple sets of keys. If our hash function $H_s(-)$ is suitably secure, the lazy user can re-use the same constants $\mu$ and $\gamma$ without concern; nevertheless, it is recommended that users do not re-use constants in $\texttt{MERGE}$. 
 \end{disc}
 
 \begin{disc}
 The above description exploits the notion that an $(N-1)$-of-$N$ signature is an $N^*$-of-$N^*$ signature for $N^*=\frac{N(N+1)}{2}$, allowing to appear in the defining sum $Y_{\texttt{shared}} = \sum_{i,j} H_s (Z_{i,j}, \mu_{i,j})$ multiple times. This allows $\texttt{MERGE}$ to be called at one level of recursion, and ensured consistency in step (5) above\todo{Uhm. I got nervous about what happens if $z_{i,j}$ repeat and the uniqueness of $s_{k,j}$... I think the algebra works out...}.
 \end{disc}
 
 
 \section{Security Proofs}
 
 Note that for our restricted RTM described in Section \ref{sec:implement} only accepts thresholds $t$ such that $2 \leq N-1 \leq t \leq N$ and only merges keys of depth zero. 
 
 To deal with our security proofs, we use the  fact proven in \cite{scozzafava1993uniform} that the sum of a uniform random variable with any indepenent random variable in $\mathbb{Z}/m\mathbb{Z}$ results in a uniform random variable (and conversely when $m$ is prime). Hence, no PPT algorithm will be able to distinguish between a uniform random variable $U$ and a sum of uniform random variables, $\sum_i U_i$.
 
 Assume $H_s$, $H_p$ in the RTM implementation from Section \ref{sec:implement} are cryptographic hash functions under the random oracle model whose outputs are statistically indistinguishable from a uniform distribution except with non-negligible probability, and whose outputs are independent of one another. Assume the discrete log hardness assumption holds.
 
 \begin{thm}The RTM implementation from Section \ref{sec:implement} is CIKS.
 \end{thm}
 \begin{proof}
Either the key pair $X_b = (A,B)$ received by $\mathcal{A}$ in step (iii) of Definition \ref{threshIndistSigs} is $N$-of-$N$ (and thus has depth $1$ and threshold $t=N$), $(N-1)$-of-$N$ (and thus has depth $1$ and threshold $t=N-1$), or a usual $1$-of-$1$ key pair (and thus has depth $0$). Since $N-1 \leq t \leq N$, non-negligible information about $t$ is equivalent to non-negligible information about $N$. Moreover, $(N-1)$-of-$N$ key pairs are $N^*$-of-$N^*$ key pairs. Thus, we really only need to deal with two cases: an $N$-of-$N$ key pair with $N > 1$ (where depth is necessarily $d=1$) or a $1$-of-$1$ key pair (necessarily with depth $d=0$).
  
  %From this point of view, the depth of keys in Section \ref{sec:implement} may be regarded a bit that signifies whether the key is a threshold key or not.
  
  %Due to this, without loss of generality we may assume that $t=N$: any information gleaned about $t$ from $X_b$ in our restricted RTM in the usual game is equivalent to gaining information about $N$, and $d$ provides a test for whether $N=1$.
 
  If $(A,B)$ is an $N$-of-$N$ key pair, then $A^* = \sum_{i} H_s(a_i, \mu_i) G$ and $B^* = \sum_i H_s(b_i, \gamma_i) G$. Since $H_s$ is uniformly distributed in its output space with independent outputs, the sum of any number of digests is also uniformly distributed in output space \cite{scozzafava1993uniform}. On the other hand, if $(A,B)$ is a $1$-of-$1$ key pair, then $A$ and $B$ are each independent uniform random variables, so no PPT algorithm can determine whether $A$ or $B$ is a sum or not. This establishes that the scheme is CIK.
  
  Granting signing oracle access does nothing for $\mathcal{A}$. Signatures on a message $m$ with ring $Q$ take the form $(c_1, s_1, \ldots, s_L, J)$, where $c_1$ and each $s_i$ are observations from independent uniform random variables; these coordinates contain no information about the signing coalition of users.  The key image is $J = \sum_i b^*_i H_p(B^*)$; write this $J = b^* H_p(B^*)$. The adversary may compute $H_p(B_i)$ for each public spend key $B_i$ in $Q$, but without the ability to compute the discrete log of $J$ with respect to these points, $\mathcal{A}$ can gain only negligible information about $b^*$. Moreover, even if $\mathcal{A}$ gains non-negligible information about $b^*$, since each $b^*_i$ was fairly generated using $\texttt{GEN}(1^{\lambda})$, the adversary still will not be able to determine whether $b^*$ is a sum or not, and if so, will not be able to determine how many contributing elements are in the sum. This establishes that the scheme is CIKS.
  
  
  
  \end{proof}
 
 \begin{thm} The RTM implementation from Section \ref{sec:implement} is st-EUF.
 \end{thm}
 \begin{proof}
 \end{proof}

%If we assume all threshold members are honest, the scheme reduces to the usual LSAG signature as in \cite{liu2004linkable}. However, this is an undesirable assumption for applications in cryptocurrency. Definition \ref{defn:unf} is inadequate in the threshold setting because, if some $B_i$ is a $t_i$-of-$n_i$ shared public key in the ring, the adversary may query the oracle $\mathcal{SO}$ to sign messages on behalf of some of the $n_i$ members sharing the public key $B_i$ without violating the conditions of Definition \ref{defn:unf}. Do to this, we consider Definition \ref{defn:unf2} to describe adaptive chosen message attacks where insiders. 

%Since we may regard any $(n-1)$-of-$n$ instantiation of the above scheme as an $n^*$-of-$n^*$ instantiation, it is sufficient to prove that any $n$-of-$n$ instantiation is secure. The $1$-of-$1$ instantiation is merely the LSAG signature from \cite{liu2004linkable}; in this setting, Definitions \ref{defn:unf} and \ref{defn:unf2} coincide, so we only must concern ourselves with $n$-of-$n$ instantiations with $n \geq 2$.

%The strength of the security proof from \cite{liu2004linkable} rests on novel rewind-on-success simulations. Rewind simulations were first presented as the forking lemma in \cite{pointcheval1996security} and the heavy row lemma in \cite{ohta1998concrete}; rewind-on-success simulations are first presented in \cite{liu2004linkable}. With a master PPT $\mathcal{M}$ invoking a PPT adversary $\mathcal{A}$ to obtain a transcript $\mathcal{T}$ in an attack game on some scheme $\Pi$ may, the rewind-on-success simulation will, upon finding a success in $\mathcal{T}$,  rewind $\mathcal{T}$ to some point, header $h$ and ``begin again'' to seek an additional success. Resimulating $\mathcal{A}$ with new random data, $\mathcal{M}$ generates a new transcript $\mathcal{T}^*$ where $\mathcal{T}$ and $\mathcal{T}^*$ are identical up to (and including) header $h$. It is established in \protect{\cite[Lem E.1]{liu2004linkable}} that the probabilities of success of $\mathcal{T}$ and $\mathcal{T}^*$ are identical (although this says nothing of their independence). Thus an attacker who can find one success with non-negligible probability can find any finite number they desire using rewind-on-success with non-negligible probability.

%Thus, if the adversary can successfully compute one forged signature on a message with non-negligible probability, say $\sigma = (c_1, s_1, \ldots, s_N, J)$, then that adversary can rewind and compute a second forged signature with the same key image but different random values $s_i^*$, say $\sigma^* = (c_1^*, s_1^*, \ldots, s_N^*, J)$, also with non-negligible probability. In checking that these forgeries satisfy verification, the adversary must compute the commitments in the LSAG signature, and hence must query some hash function $H$ at least once per commitment. So the adversary must make as many queries to $H$ as there are ring members, $L$, each of the form $H(J,m, sG + cB, sH(B) + cJ)$, where $B$ is a public key in the ring and $J$ is the key image associated to the signature. In computing the first forgery, the adversary must compute some first commitment $H(m,J, uG, vG^{\prime}) = H(m,J, sG + cB, sH(B) + cJ)$, where $u$, $v$, and the base point $G^{\prime}$ are each unknown before rewinding. After rewinding and computing a second forgery, the adversary has the system of equations
%\begin{align*}
    %uG =& sG + cB\\
    %uG =& s^*G + c^*B\\
    %vG^{\prime} =& sH(B) + cJ\\
    %vG^{\prime} =& s^*H(B) + c^*J\\
%\end{align*}
%The adversary can then compute the secret key $b = \frac{s-s^*}{c^*-c}$, solving the discrete log problem $B = bG$.

%This proof extends directly to MLSAG signatures; this was claimed in \cite{noether2016ring} but the proof therein contained a mistake, which we correct here:
%\todo{Shen's security theorem and corrected proof}
%\begin{thm}
%*
%\end{thm}
 

%The signatories must make several joint decisions in the process described under Section \ref{sec:implement}. We are vague in their description because the implementation of these steps can be done in many ways. 

%For example, in Step 3, the signatories decide upon a ring and a secret index to store their public keys. This may be done by merely having some member do it randomly (introducing a sort of Byzantine General problem), or using some deterministic (but seemingly random) method chosen ahead of time in meatspace based on the input message. The secret index should appear to be uniformly random, regardless of method employed. Note that one of the signatories can publicly communicate a sort of encryption of the secret index without harm by merely publishing the ring of public keys $Q$; other signatories know their own public keys, so they can inspect the ring and determine the secret index without any further information from the first signatory and without observers being able to discern which index is the threshold key.

%Also in Step 3, the signatories decide on the values of $s_i$ randomly. One method is for each signatory to compute their own $s_{i,j}$ and computing the shared sums $s_i = \sum_j s_{i,j}$. This requires a lot of interaction; another method is to simply let one threshold member do it and communicate the values to the group with authentication. Note that the values $s_i$ are eventually made public in the signature and there is no harm in sharing these values without encryption. Similarly, in step 8, we compute the sum $\sum_j s_{i^{\prime},j}$; since each user keeps their $u_j$ secret, they can reveal their $u_j - c_{i^{\prime}} b_j^*$ or $u_j - c_{i^{\prime}} \sum_{i=1}^{L} z_{i,j}$ without risking their private keys, so there is no harm in sharing these values without encryption.

%To communicate a message with authentication, we use the HMAC scheme: for the $j^{th}$ threshold member to communicate a message $M$ to the $i^{th}$ threshold member, a shared secret $t_{i,j}$ is computed and $(M, \texttt{HMAC}(t_{i,j}, M))$ is sent. For a CCA-secure encrypt-and-authenticate scheme \cite{katzAndLindell}, two users generate two shared secrets $t_{i,j}$, $t^*_{i,j}$. The sending user computes the ciphertext $C = \texttt{Enc}(t_{i,j}, M)$ and the authentication codes $\tau = \texttt{HMAC}(t^*_{i,j}, C)$ and sends $(C,\tau)$ to the receiver. If a receiver sees some $(C,\tau)$, they can check if $\tau$ is a valid HMAC on $C$ for any of their shared secrets. If so, they can decrypt $C$ with the other shared secret.




%\begin{comment}


%Additional properties are often required in application, such as \textit{linkability}: an adversary can feasibly identify whether two signatures have been fashioned by some common private keys. In the case of usual ring signatures, this is an obvious question: if the true signer of two signatures is the same, output $1$, otherwise $0$. Linkability schemes can be de-anonymizing if the process reveals more than just a bit, like the associated user public key (or worse, the user secret key). Unfortunately, in the case of $t$-of-$n$ threshold signatures, the property of linkability comes in several flavors.


%A brief notational consideration: for some signature $\sigma$ generated by following the protocol honestly, denote $P^*_\sigma$ as the ring of public signing keys associated with $\sigma$, denote $(sk^*_\sigma, pk^*_\sigma)$ as the signing keypair of the signatory for $\sigma$. For such a signature, there must have existed a $t$-of-$n$ configuration of users (recall this is a collection of user secret keys), which comes equipped with a set of user public keys $P_\sigma$, and a subset of the associated user secret keys $S_\sigma$. Denote the set of public keys associated with the user secret keys in $S_\sigma$ as $P(S_\sigma)$.

%A t-of-n threshold ring signature scheme can be made into a linkable $t$-of-$n$ threshold ring signature if it comes equipped with an PPT algorithm \texttt{Lnk} that outputs a bit if two input signatures are linked. Implementation of \texttt{Lnk} depends critically on the application. If linkability is defined such that we only detect when \textit{exact same} $t$-of-$n$ configuration of users signed two signatures, then it is possible that a group of $n=t+1$ users conspire to fashion $t+1$ different $t$-of-$n$ threshold ring signatures, each with a unique $t$-of-$n$ configuration. Hence, these signers are able to fashion as many different $t$-of-$n$ signatures as they have conspirators before linkability reveals their behavior. On the other hand, by requiring all user keys from \texttt{GenUserKey} be one-time keypairs generated in a Diffie-Hellman exchange, this forces all of our signatures to be one-time signatures and the problem is resolved.

%On the other end of the spectrum, presume linkability is defined such that two signatures are linked if \textit{at least one} user private key is used in common between two signatures. Then each private key can participate in at most one signing, regardless of the size of coalition of users $n$ or threshold $t$, before use of their private key will lead to linkage. This may be undesirable for many applications, but the appeal for use in e-cash schemes is obvious. 

%We use the following terminology. If an adversary can feasibly compute some nontrivial function of the sets $P(S_{\sigma_1})$ and $P(S_{\sigma_2})$, we say the scheme is \textit{leaky}.  If an attacker can feasibly determine whether $P(S_{\sigma_1}) = P(S_{\sigma_2})$, then we say that the scheme is \textit{linkable}. If an attacker can feasibly determine whether $P(S_{\sigma_1}) \cap P(S_{\sigma_2}) = \emptyset$, then we say that the scheme is \textit{individually linkable}.   Certainly every linkable scheme and every individually linkable scheme is leaky. If an adversary can feasibly compute some nontrivial function of the sets $S_{\sigma_1}$ and $S_{\sigma_2}$, we say the scheme is \textit{very leaky}. Note that every very leaky scheme is leaky. We attain a hierarchy induced by both linkability and leakage.


%Recall that a usual ring signature is a $1$-of-$1$ threshold ring signature. Thus, a linkable ring signature is a linkable $1$-of-$1$ threshold ring signature. In particular, given two signatures, an adversary can feasibly determine whether the public key of the signer of both signatures is the same. It's clear that in this scenario, the notion of linkability and the notion of individual linkability coincide.


%For our purposes, we use a \texttt{Lnk} algorithm that takes as input a $t_1$-of-$n_1$ signature $\sigma_1$ on message $M_1$ with possible signing public keys $P^*_1$, a $t_2$-of-$n_2$ signature $\sigma_2$ on message $M_2$ with possible signing public keys $P^*_2$. The algorithm outputs a bit if any secret key used to generate $\sigma_1$ was also used to generate $\sigma_2$.

%In a linkable $t$-of-$n$ threshold ring signature with, say $L$ ring members, each ring member consists of some $t$-of-$n$ threshold configuration of user keys. In this way, each signature implicates $L$ threshold configurations, each with $t$ users, so each signature implicates $tL$ users. If any particular $t$-of-$n$ threshold configuration


\section{Further Analysis}

\subsection{Efficiency and comparisons}

\subsection{Elaborations}


 %A stronger version of Definition \ref{threshIndist} is available by granting the adversary access to a signing oracle, providing coalition indistinguishable keys and signatures against chosen message attacks (CIKS-CMA), which guarantees that not only are \textit{keys} coalition-indistinguishable, but also signatures, even if the adversary can obtain arbitrary signatures.
 
 On the other hand, we may be tempted to strengthen Definition \ref{threshIndist} to take into account corruption oracle access on the part of the adversary. Unfortunately this leads to certain problems with the security definition. However, we can tweak the implementation in Section \ref{naiveImplement} so that coalition members select constants $\mu_j$ (or select random shared secrets $\mu_{i,j}$) and compute the shared key as $Y_{\texttt{shared}} := \sum_j H_s(X_j, \mu_j)G$ in the $N$-of-$N$ case (or as $Y_{\texttt{shared}} := \sum_{1 \leq i < j \leq N} H_s(Z_{i,j}, \mu_{i,j})G$ in the $(N-1)$-of-$N$ case, respectively). Without knowledge of the values of $\mu_j$, even if the adversary corrupts all the public keys in $S$, then $\mathcal{A}$ cannot successfully run $\texttt{MERGE}$ for each value $1 \leq t \leq \left|S\right|$ to check the results by hand in comparison against the key $X_b$ from step (iii). Moreover, each $\mu_j$ (or $\mu_{i,j}$) is a secret scalar. These are never made public, but also the associated public points $\mu_j G$ and $\mu_{i,j} G$ are never directly published. Thus, if the participating coalition members keep each $\mu_*$ secret, then even a very powerful adversary with oracle access for computing discrete logs will still be unable to discern whether some $Y$ is a coalition key.



\emph{Special Thanks}: We would like to issue a special thanks to the members of the Monero community who used the GetMonero.org Forum Funding System to support the Monero Research Lab. Readers may also regard this as a statement of conflict of interest, since our funding is denominated in Monero and provided directly by members of the Monero community by the Forum Funding System.

\medskip{}

\bibliographystyle{plain}
\bibliography{biblio.bib}

\end{document}
